@inject IJSRuntime _js
@inject TrackService _trackService
@inherits AppBase

<div class="window app-component draggable" id="@AppId">
	<div class="title-bar">
		<button aria-label="Close" class="close" @onclick="Remove">✕</button>
		<h1 class="title">hxbc.FM</h1>
		<button aria-label="Resize" disabled class="hidden"></button>
	</div>
	<div class="separator"></div>
	<div class="window-pane">
		<div class="content">
			<!-- Cassette Player -->
			<div class="cassette-player" style="--track-color: @GetTrackColor(_currentTrack)">

				<!-- Cassette Tape -->
				<div class="cassette-body">
					<div class="cassette-top">
						<!-- Left Reel -->
						<div class="reel-container">
							<div class="reel @(_isPlaying ? "spinning" : "")">
								<div class="reel-center"></div>
								<div class="reel-spokes">
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
								</div>
							</div>
						</div>

						<!-- Track Info Display -->
						<div class="cassette-display">
							@if (_currentTrack is not null)
							{
								<div class="track-name">@_currentTrack.Name</div>
								<div class="track-artist">@_currentTrack.Artist</div>
								<!-- Visualizer -->
								<div class="visualizer">
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
									<div class="bar"></div>
								</div>
							}
						</div>

						<!-- Right Reel -->
						<div class="reel-container">
							<div class="reel @(_isPlaying ? "spinning" : "")">
								<div class="reel-center"></div>
								<div class="reel-spokes">
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
									<div class="spoke"></div>
								</div>
							</div>
						</div>
					</div>

					<!-- Tape -->
					<div class="tape-section">
						<div class="tape-window">
							<div class="progress-bar">
								<div class="progress"></div>
							</div>
						</div>
					</div>

					<!-- Controls -->
					<div class="cassette-controls">
						<button class="control-btn prev-btn" @onclick="PlayPrevious">
							<img src="img/prev.svg" />
						</button>
						<button class="control-btn play-btn" @onclick="PlayPause">
							@if (_isPlaying)
							{
								<img src="img/pause.svg" />
							}
							else
							{
								<img src="img/play.svg" />
							}
						</button>
						<button class="control-btn next-btn" @onclick="PlayNext">
							<img src="img/next.svg" />
						</button>
					</div>
				</div>

			</div>

			<!-- Track List -->
			<div class="track-list">
				@for (int i = 0; i < _tracks.Count; i++)
				{
					var track = _tracks[i];
					var trackColor = GetTrackColorByIndex(i);
					<div class="track @(_currentTrack == track ? "selected" : "")" style="--track-color: @trackColor"
						@onclick="() => SelectTrack(track)">
						<div class="track-color-indicator"></div>
						<div class="track-info">
							<div class="track-title">@track.Name</div>
							<div class="track-subtitle">@track.Artist • @string.Join(", ", track.Genres)</div>
						</div>
					</div>
				}
			</div>
		</div>
	</div>
</div>
@code {
	DotNetObjectReference<AudioPlayer>? _dotNetRef;

	List<Track> _tracks = new();

	Track? _currentTrack = null;
	bool _isPlaying = false;

	override protected async Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);
		if (firstRender)
		{
			_dotNetRef = DotNetObjectReference.Create(this);
			await _js.InvokeVoidAsync("initializeAudioPlayer", _dotNetRef);
			var tracks = await _trackService.GetTracks();
			foreach (var track in tracks.Shuffle())
			{
				_tracks.Add(track);
			}
			_currentTrack = _tracks[0];
			if (_currentTrack is not null)
			{
				await _js.InvokeVoidAsync("playAudio", _currentTrack.Url);
				_isPlaying = true;
			}
			StateHasChanged();
		}
	}

	void PlayPause()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);

		}
		else
		{
			_js.InvokeVoidAsync("playPauseAudio");
		}
		_isPlaying = !_isPlaying;
	}

	[JSInvokable("PlayNext")]
	public void PlayNext()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
		}
		else
		{
			var currentIndex = _tracks.IndexOf(_currentTrack);
			if (currentIndex < _tracks.Count - 1)
			{
				_currentTrack = _tracks[currentIndex + 1];
				_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
			else
			{
				_currentTrack = _tracks[0];
				_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
		}
		_isPlaying = true;
		StateHasChanged();
	}

	void SelectTrack(Track track)
	{
		_currentTrack = track;
		_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
		_isPlaying = true;
	}

	void PlayPrevious()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
		}
		else
		{
			var currentIndex = _tracks.IndexOf(_currentTrack);
			if (currentIndex > 0)
			{
				_currentTrack = _tracks[currentIndex - 1];
				_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
		}
		_isPlaying = true;
	}

	protected async override void Remove()
	{
		_isPlaying = false;
		await _js.InvokeVoidAsync("stopAudio");
		_dotNetRef?.Dispose();
		base.Remove();
		StateHasChanged();
	}

	private string GetTrackColor(Track? track)
	{
		if (track == null) return "#333";
		var index = _tracks.IndexOf(track);
		return GetTrackColorByIndex(index);
	}

	private string GetTrackColorByIndex(int index)
	{
		var colors = new[]
		{
"#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#feca57",
"#ff9ff3", "#54a0ff", "#5f27cd", "#00d2d3", "#ff9f43",
"#74b9ff", "#0984e3", "#6c5ce7", "#a29bfe", "#fd79a8",
"#fdcb6e", "#e17055", "#81ecec", "#fab1a0", "#ff7675"
};
		return colors[index % colors.Length];
	}
}