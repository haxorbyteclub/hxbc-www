@inject IJSRuntime _js
@inject YoutubeService _youtube
@inherits AppBase

<div class="app-component draggable" id="@AppId">
	<div class="header">
		<span class="spacer">
			<i></i>
			<i></i>
			<i></i>
		</span>
		<span class="header-title">Audio Player</span>
		<span class="spacer">
			<i></i>
			<i></i>
			<i></i>
		</span>
		<button class="close-btn" @onclick="Remove">x</button>
	</div>
	<div class="content">
		<div class="media-player">
			<div class="display">
				<div>
					<div class="track-info">
						<span>@_currentTrack?.Name</span>
					</div>
					<div class="track-details">
						<span class="audio-current-time">00:00</span>
					</div>
				</div>
				<!-- 4 random euqalizer bars -->
				<div class="equalizer">
					<div class="bar"></div>
					<div class="bar"></div>
					<div class="bar"></div>
					<div class="bar"></div>
					<div class="bar"></div>
				</div>
			</div>
			<div class="controls">
				<button class="btn prev" @onclick="PlayPrevious">
					<img src="img/prev.svg" />
				</button>
				<button class="btn play" @onclick="PlayPause">
					<img src="img/play.svg" />
				</button>
				<button class="btn next" @onclick="PlayNext">
					<img src="img/next.svg" />
				</button>
			</div>
			<div class="progress-bar">
				<div class="progress"></div>
			</div>
			<div class="track-list">

				@foreach (var track in _tracks)
				{
					@if (_currentTrack == track)
					{
						<div class="track selected">@track.GetName()</div>
					}
					else
					{
						<div class="track" @onclick="() => SelectTrack(track)">@track.GetName()</div>
					}
				}
			</div>
		</div>
	</div>
</div>
@code {
	List<Track> _tracks = new();

	Track? _currentTrack = null;

	override protected async Task OnAfterRenderAsync(bool firstRender)
	{
		await base.OnAfterRenderAsync(firstRender);
		if (firstRender)
		{
			var tracks = await _youtube.GetTracks();
			foreach (var track in tracks.Shuffle())
			{
				_tracks.Add(track);
			}
			_currentTrack = _tracks[0];
			StateHasChanged();
			if (_currentTrack is not null)
			{
				await _js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
		}
	}

	void PlayPause()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);

		}
		else
		{
			_js.InvokeVoidAsync("playPauseAudio");
		}
	}

	void PlayNext()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
		}
		else
		{
			var currentIndex = _tracks.IndexOf(_currentTrack);
			if (currentIndex < _tracks.Count - 1)
			{
				_currentTrack = _tracks[currentIndex + 1];
				_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
		}
	}

	void SelectTrack(Track track)
	{
		_currentTrack = track;
		_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
	}

	void PlayPrevious()
	{
		if (_currentTrack == null)
		{
			_currentTrack = _tracks[0];
			_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
		}
		else
		{
			var currentIndex = _tracks.IndexOf(_currentTrack);
			if (currentIndex > 0)
			{
				_currentTrack = _tracks[currentIndex - 1];
				_js.InvokeVoidAsync("playAudio", _currentTrack.Url);
			}
		}
	}

	protected async override void Remove()
	{
		await _js.InvokeVoidAsync("stopAudio");
		base.Remove();
	}
}